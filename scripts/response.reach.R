
#This script takes the OUtput from GUT and summarizes responses by reach

#This script smmarizes geomorphic assemblages by reach

#Natalie Kramer (n.kramer.anderson@gmail.com)
#Last Updated July 13 2019

#Documentation available on 
#https://natalie-kramer.github.io/GeomorphicUpscale/


# To Do -------------------------------------------------------------------

# As JM if fish count per unit lenght should use thalweg of main channl or sum of all channels (NK had set to just main)
# Capitalize species and lifestage
# Nk calculates volume using 'bfd' variable.  keeping for now but will need to change based on champ metrics field
#       - note this really isn't a good metric since bfd is reach average bankfull depth and doesn't really represent
#         volume well.  will do away with but just carrying over in meantime in case she uses it in subsequent scripts

# NKS old to dos
# Do response by size by RS and no pooling?, currently just RSCond---if folders are flip flopped, this makes it easier...
# I need to add the lineear model results for response by size
# flip flop RSCond folders with response types so that it mirrors the other outputs in long format for unit responses.

# eliminate species and model from directory structure and instead include as field in output table?  Maybe append to this table
# when run for different species or just run for all species and model types on the fly-- not make a user variable...?

# Dependencies ------------------------------------------------------------

library(tidyverse)

source(file.path(repo.dir, "scripts\\plot.colors.R"))
source(file.path(repo.dir, "scripts\\functions.R"))

# user variables defined in UpscaleWrapper.R ------------------------------------------------------------

proj.dir = proj.dir  #directory path to local project
repo.dir = repo.dir   #directory path to Github repo
selections = selections #directory path to input selections file generated by RSselection.R
gu.type = gu.type      #Options: UnitForm, GU #UnitShape not available at this time since I don't have maps of these in the database
RSlevels = RSlevels #optional vector argument to set RS factor order in graphs and displays, leave as  NA if alphabetical is desired
in.species = species   #Options: steelhead, chinook
in.model = model    ##Options: nrei, fuzzy
in.lifestage = lifestage  ##Options: spawner, juvenile


# set directories and paths ------------------------------------------------------------------------

# set response output directory
# note: str_to_sentence will convert first letter of species and lifestage to upper case
response.dir = file.path(proj.dir, "Outputs/Response", str_to_sentence(in.species), str_to_sentence(in.lifestage), "Reach")
if(!file.exists(response.dir)){dir.create(response.dir, recursive = TRUE)}

# create respons subdirectories for each prediction type
if(!file.exists(file.path(response.dir, "pred.fish"))){dir.create(file.path(response.dir, "pred.fish"), recursive = TRUE)}
if(!file.exists(file.path(response.dir, "pred.fish.m"))){dir.create(file.path(response.dir, "pred.fish.m"), recursive = TRUE)}
if(!file.exists(file.path(response.dir, "pred.fish.m2"))){dir.create(file.path(response.dir, "pred.fish.m2"), recursive = TRUE)}

# set path to repo gut metric tables
metrics.dir = file.path(repo.dir, "Database/Metrics")

# specify gut output layer and corresponding metric table to draw data from based on gu.type parameter
if(gu.type == "GU"){
  layer = "Tier3_InChannel_GU" 
  site.gut.metrics = "Site_GUTMetrics_Tier3_InChannel_GU.csv"}
if(gu.type == "UnitForm" | gu.type == "UnitShape"){
  layer = "Tier2_InChannel"
  site.gut.metrics = "Site_GUTMetrics_Tier2_InChannel.csv"}

# read in site metric fish data
site.fish.metrics = read_csv(file.path(metrics.dir, "Site_Fish_Metrics.csv"))

# makes layer with just site level resonse for model, species and lifestage specified.
site.fish = site.fish.metrics %>% 
  filter(layer == in.model & species == in.species & lifestage == in.lifestage & var == "pred.fish")


# make site summaries for different response and ROI -----------------------

# predicted fish total in reach 
pred.count.hydro = site.fish %>% 
  filter(category == "reach") %>% 
  mutate(ROI = "hydro") %>% 
  rename(pred.n = value) %>% 
  select(visit.id, pred.n, ROI)

# reach main thalweg length (note - clipped to modeled extent)
hydro.thalweg = site.fish.metrics %>%
  filter(layer == "thalweg", category == "main") %>%
  select(visit.id, value) %>%
  rename(length.m = value)

# reach area (note - clipped to modeled extent)
hydro.area = site.fish.metrics %>%
  filter(var == "area", category == "reach", layer == in.model, species == in.species, lifestage == in.lifestage) %>%
  select(visit.id, value) %>%
  rename(area.m2 = value)

# join fish count, thalweg length, reach area and calculate fish densities
pred.hydro = pred.count.hydro %>%
  left_join(hydro.thalweg, by = "visit.id") %>%
  left_join(hydro.area, by = "visit.id") %>%
  mutate(pred.m = pred.n / length.m) %>%
  mutate(pred.m2 = pred.n / area.m2) %>%
  select(visit.id, ROI, length.m, area.m2, everything())


# computes density spread over entire BF area rather than hydro extent. sort of fictitious but needed for upscaling.
pred.bf = read_csv(file.path(metrics.dir, site.gut.metrics)) %>%
  rename(area.m2 = bf.area.m2, length.m = main.thalweg.length.m) %>%
  select(visit.id, area.m2, length.m) %>%
  full_join(pred.count.hydro, by = "visit.id") %>%
  mutate(pred.m = pred.n / length.m, pred.m2 = pred.n / area.m2, ROI = "bankfull" ) 


# combine bankfull and hydro (i.e., modeled wetted) predictions into single df
pred = rbind(pred.hydro, pred.bf)

# join predictions to selections
site.response = selections %>% 
  select(RS, Condition, visit.id) %>%
  inner_join(pred, by = 'visit.id') %>%
  mutate(unit.type = "all")

# convert to long format for use in make.outputs code
site.response.long = site.response %>%
  gather(key = "variable", value = "value", pred.n, pred.m, pred.m2)

# function to summarize data pooling in different ways and write to files
make.all.outputs = function(){
  make.outputs(my.data, pool.by = "All", out.dir, my.facet = "ROI", RSlevels)
  make.outputs(my.data, pool.by = "RS", out.dir, my.facet = "ROI", RSlevels)
  make.outputs(my.data, pool.by = "RSCond", out.dir, my.facet = "ROI", RSlevels)
}

print("Making site level fish response summaries and plots")

# make output for predicted fish count -----------------------

# set output directory
out.dir = file.path(response.dir, "pred.fish")
# delete any existing files in Output from previous runs
unlink(file.path(out.dir,"*"), recursive = TRUE)
# set data
my.data = site.response.long %>% filter(variable == "pred.n")
# make summaries
make.all.outputs()


# make output for predicted fish density per length (m) -----------------------

# set output directory
out.dir = file.path(response.dir, "pred.fish.m")
# delete any existing files in Output from previous runs
unlink(file.path(out.dir,"*"), recursive = TRUE)
# set data
my.data = site.response.long %>% filter(variable == "pred.m")
# make summaries
make.all.outputs()


# make output for predicted fish density per area (m2) -----------------------

# set output directory
out.dir = file.path(response.dir, "pred.fish.m2")
# delete any existing files in Output from previous runs
unlink(file.path(out.dir,"*"), recursive = TRUE)
# set data
my.data = site.response.long %>% filter(variable == "pred.m2")
# make summaries
make.all.outputs()


# make site summaries of count response by reach size  -----------------------
# note - here natalie was only outputing the response for fish count for hydro area
#        i expanded to include densities for both roi hydro (i.e., modeled wetted) and bankfull 

# join selections and site response
selections.site.response = selections %>%
  mutate(model = in.model, species = in.species, lifestage = in.lifestage) %>%
  inner_join(pred, by = "visit.id") %>%
  mutate(volume = area.m2 * bfd)


# write to file
write_csv(selections.site.response, file.path(response.dir, "Response.csv"), col_names = TRUE)

# sets order for RS factor levels
if(!all(is.na(RSlevels))){selections.site.response$RS = factor(selections.site.response$RS, levels = RSlevels)}

# create base plot
# TO DO: add regression output summaries
p = ggplot(selections.site.response %>% filter(ROI == "hydro"), aes(y = pred.n, color = Condition)) +
  scale_colour_manual(values = condition.fill) +
  facet_grid(Condition ~ RS, scales = "fixed")

#plot
(p + geom_point(aes(x = bfw), alpha = 0.8)) %>% ggsave(filename = file.path(response.dir,"by.width.bankfull.m.png"), width = 15, height = 5)
(p + geom_point(aes(x = bfd), alpha = 0.8)) %>% ggsave(filename = file.path(response.dir,"by.depth.bankfull.m.png"), width = 15, height = 5)
(p + geom_point(aes(x = length.m), alpha = 0.8)) %>% ggsave(filename = file.path(response.dir,"by.length.hydro.m.png"), width = 15, height = 5)
#This is hydroarea*bfd, not perfect, better to have average hydrodepth, but I don't have that variable.
(p + geom_point(aes(x = volume), alpha = 0.8)) %>% ggsave(filename = file.path(response.dir,"by.volume.as.hydroarea.bfdepth.m3.png"), width = 15, height = 5)
(p + geom_point(aes(x = Braid), alpha = 0.8)) %>% ggsave(filename = file.path(response.dir,"by.braid.index.champ.png"), width = 15, height = 5)
(p + geom_point(aes(x = area.m2), alpha = 0.8)) %>% ggsave(filename = file.path(response.dir,"by.area.hydro.m2.png"), width = 15, height = 5)


