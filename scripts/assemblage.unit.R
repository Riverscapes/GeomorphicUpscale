#Estimates Empirical assemblages of geomorphic units as percent of bankful area of each unit type for
#reach selections from RSselection.R. 

#Natalie Kramer (n.kramer.anderson@gmail.com)
#Last Updated Aug 10 2019

#Documentation available on 
#https://natalie-kramer.github.io/GeomorphicUpscale/

# To Do ------------------------------------------------------------


# Dependencies ------------------------------------------------------------

library(tidyverse)

source(file.path(repo.dir, "scripts\\plot.colors.R"))
source(file.path(repo.dir, "scripts\\functions.R"))


# user variables defined in UpscaleWrapper.R ------------------------------------------------------------
proj.dir = proj.dir  #directory path to local project
repo.dir = repo.dir   #directory path to Github repo
selections = selections #directory path to input selections file generated by RSselection.R
gu.type = gu.type      #Options: UnitForm, GU #UnitShape not available at this time since I don't have maps of these in the database
RSlevels = RSlevels #optional vector argument to set RS factor order in graphs and displays, leave as  NA if alphabetical is desired


# set directories  ------------------------------------------------------------------------

# set assemblage output directory
assemblage.dir = file.path(proj.dir, "Outputs/Assemblage", gu.type, "Unit")
if(!file.exists(assemblage.dir)){dir.create(assemblage.dir, recursive = TRUE)}

# set path to repo gut metric tables
metrics.dir = file.path(repo.dir, "Database/Metrics")

# specify gut output layer and corresponding metric table to draw data from based on gu.type parameter
if(gu.type == "GU"){
  layer = "Tier3_InChannel_GU" 
  gut.metrics = "Unit_GUTMetrics_Tier3_InChannel_GU.csv"}
if(gu.type == "UnitForm" | gu.type == "UnitShape"){
  layer = "Tier2_InChannel"
  gut.metrics = "Unit_GUTMetrics_Tier2_InChannel.csv"}


# Read in and preps unit data ----------------------------------------------------------

# read in unit data and convert to long data format
unit.metrics = read_csv(file.path(metrics.dir, gut.metrics)) %>%
    select(-gut.layer)%>%
    gather(value = "value", key = "variable", -visit.id, -unit.type) %>%
    mutate(ROI = "bankfull")
  
#combine Unit data with selections
unit.data = selections %>% 
  select(RS, Condition, visit.id) %>%
  inner_join(unit.metrics, by = 'visit.id') %>%
  filter(!is.na(unit.type))
  
# summarize variables in GUT unit summary ----------------------------------------------

# summarize variables in GUT summary
print("making site summary tables and plots...")


stats.RSCond = make.outputs.unit(unit.data, pool.by = "RSCond", gu.type = gu.type, out.dir = assemblage.dir, RSlevels = RSlevels)
stats.RS = make.outputs.unit(unit.data, pool.by = "RS", gu.type = gu.type, out.dir = assemblage.dir, RSlevels = RSlevels)
stats = make.outputs.unit(unit.data, pool.by = "All", gu.type = gu.type, out.dir = assemblage.dir, RSlevels = RSlevels)


# estimating assemblage estimates from average proportions ----------------------------------------------

print("making assemblage tables and plots...")

# function that makes renormalized assemlages and plots them 
# assemblages based on area.ratio from gut unit metrics, where
#   area.ratio = sum(areas for unit type i) / sum(areas for all unit types)
# note: here natalie is using the average area.ratio form pool.by results
assemblage.proportions = function(my.stats, pool.by, my.ROI = "bankfull", out.dir = assemblage.dir){
  
  # set output subdirectory name based on 'pool.by' argument
  if(pool.by == "RS"){
    sub.out.dir = file.path(out.dir, "byRS")
  }else if(pool.by == "RSCond"){
    sub.out.dir = file.path(out.dir, "byRSCond")
  }else{
    sub.out.dir = file.path(out.dir, "byAll")  
  }
  
  #filter data for just proportions of reach occupied by each unit
  assemblage = my.stats %>% 
    filter(variable == "area.ratio", ROI == my.ROI) %>%
    select(-sd,-med, -min, -max, -n, -tot)
  
  # spreads table grouped by pool.by so that unit types are converted to columns
  if(pool.by == "RSCond"){
    assemblage.group = assemblage %>%
      group_by(RS, Condition) %>%
      spread(key = "unit.type", value = avg) %>%
      ungroup()
  }
  
  if(pool.by=="RS"){
    assemblage.group = assemblage %>%
      group_by(RS) %>%
      spread(key = "unit.type", value = avg) %>%
      ungroup
  }
  
  if(pool.by == "All"){
    assemblage.group = assemblage %>%
      spread(key = "unit.type", value = avg)
  }
  
  # makes list of unit types and find starting and ending column for renormalization
  unit.list = levels(as.factor(my.stats$unit.type))
  start.col = length(names(assemblage.group)) - length(unit.list) + 1
  end.col = length(names(assemblage.group))
  
  # renormalize proportions to sum to 100
  assemblage.norm = assemblage.group %>% ungroup() %>%
    mutate(SUM1 = select(., start.col:end.col) %>% apply(1, sum, na.rm = TRUE)) %>% #make sum across proportions
    mutate_at(start.col:end.col, funs(./SUM1)) %>% #renormalize columns
    mutate(SUM = select(.,start.col:end.col) %>% apply(1, sum, na.rm = TRUE)) %>% #check math
    select(-SUM1)
  
  # save output
  write_csv(assemblage.norm, file.path(sub.out.dir, "assemblage.csv"), col_names = TRUE)
  
  # call function to make plots
  assemblage.plot(assemblage.norm, pool.by, start.col, end.col, out.dir = sub.out.dir)

}

# function to plot assemblage. Used within assemblage.proportions function
assemblage.plot = function(assemblage.data, pool.by, start.col, end.col, out.dir){
  
  #Read in and manipulate data for plotting
  my.data = assemblage.data %>%
    gather(key = "Unit", value = "value", start.col:end.col) %>%
    select(-SUM)
  
  # sets colors and factor orders for plotting
  
  # condition levels for plots hard coded as "poor", "mod", "good", "intact" to show up in correct order
  if(pool.by == "RSCond"){
    my.data$Condition = factor(my.data$Condition, levels = condition.levels)}
  
  # set RSlevel order (if not set to NA)
  if(pool.by != "All"){
    if(!all(is.na(RSlevels))){my.data$RS = factor(my.data$RS, levels = RSlevels)}}
  
  a = set.levels.colors(my.data, gu.type, repo.dir, unitcolname = "Unit")
  unit.colors = a$unit.colors
  # my.data = a$my.data # commenting out.  not sure why nk was overwriting here
  
  #makes assemblage plots
  if(pool.by == "All"){
    p1 = ggplot(my.data, aes(x = ROI, y = value, fill = Unit)) +
      geom_bar(stat = "identity", position = 'stack') +
      scale_fill_manual(values = unit.colors)
  }
  
  if(pool.by == "RS"){
    p1 = ggplot(my.data, aes(x = RS, y = value, fill = Unit)) +
      geom_bar(stat = "identity", position = 'stack') +
      scale_fill_manual(values = unit.colors)
  }
  
  if(pool.by == "RSCond"){
    p1 = ggplot(my.data, aes(x = Condition, y = value, fill = Unit)) +
      geom_bar(stat = "identity", position = 'stack') +
      scale_fill_manual(values = unit.colors) +
      facet_wrap( ~ RS, scales='free')
  }
  
  # save assemblage plots 
  ggsave(file.path(out.dir, "assemblage.pdf"), plot = p1, width = 10, height = 7 )
  ggsave(file.path(out.dir, "assemblage.png"), plot = p1, width = 10, height = 7)

}

#writes assemblages and creates plots based on specified pool.by
assemblage.proportions(stats.RSCond, pool.by = "RSCond")
assemblage.proportions(stats.RS, pool.by = "RS")
assemblage.proportions(stats, pool.by = "All")



# # cleaning up ----------------------------------------------
# 
# print("erasing temporary variables")
# 
# keepvars=c("proj.dir","repo.dir", "selections",
#            "plot.type", "my.scales" , "RSlevels", "gu.type")
# rm(list=ls()[-match(x = keepvars, table = ls())])
# 
# print("done")
  
  
