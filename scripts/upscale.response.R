#Upcales reponse by unit and river style to a network

#Natalie Kramer (n.kramer.anderson@gmail.com)
#Last Updated Aug 13 2019

#Documentation available on 
#https://natalie-kramer.github.io/GeomorphicUpscale/

# To Do ------------------------------------------------------------

# ask nk about standard deviation calculations in upscale2 -- not sure how this is being calculated...
# !!!! Unit_Fish_Metrics_Tier*_InChannel has area.delft field (hydro model - gut unit intersection) for each unit so why aren't we using this instead of bankfull areas for each unit in upscale???
# !!!! ....so assemblage should also include proprtions for wetted
# right now hokey way of calculating sd (see notes below).  why not calculate confindence interval??
# here natalie is upscaling only by unit so what was point of generating all upscale by reach stuff?
# should have ability to upscale by reach as well?

# NK: 
#eliminate species and model from directory structure and instead include as field in output table?  Maybe append to this table
#when run for different species or just run for all species and model types on the fly-- not make a user variable...?

#get rid of condition character warnings during join in upscale part.

#upscale geomorphic variables (maybe in different script?) ex.# units to reach upscale.  Also Percent of each unit type.

#Need to think about how we are summarizing predicted fish and getting sd dev. check sd calculations for correctness.
#the right now there is none because it is the total fish / tota area of a certain unit....
#perhaps we need to be summarizing by each site and then taking the average fish per unit type across sites so that 
#the standard deviation is reflective of the variation across sites rather than across units (which I am not really using...)
#so basically I would need to sum across individual units in the response script prior to summarizing the data. Then in this script, I would just use the avg rather than the tot.

# Dependencies ------------------------------------------------------------

require(tidyverse)

source(file.path(repo.dir, "scripts/plot.colors.R"))
source(file.path(repo.dir, "scripts/functions.R"))

# user variables defined in UpscaleWrapper.R ------------------------------------------------------------

proj.dir = proj.dir  # directory path to local project
repo.dir = repo.dir   # directory path to Github repo
selections = selections # directory path to input selections file generated by RSselection.R
gu.type = gu.type      # Options: UnitForm, GU #UnitShape not available at this time since I don't have maps of these in the database
RSlevels = RSlevels # optional vector argument to set RS factor order in graphs and displays, leave as  NA if alphabetical is desired
in.species = species   # Options: steelhead, chinook
in.model = model    # Options: nrei, fuzzy
in.lifestage = lifestage  # Options: spawner, juvenile

network = network
braid.index = braid.index
response.pool = response.pool #Options: "byAll", "byRS", "byRSCond"
seg.id.col = seg.id.col
length.col = length.col
width.col = width.col
cond.cols = cond.cols
area.cols = area.cols


# set up data refs and output file structure  ------------------------------------------------------------------------
print("setting up data refs and output file structure...")

# set directories and paths ------------------------------------------------------------------------

# set response input directory
# note: str_to_sentence will convert first letter of species and lifestage to upper case
response.dir = file.path(proj.dir, "Outputs/Response", str_to_sentence(in.species), str_to_sentence(in.lifestage), "Unit", gu.type, response.pool)

# set gut assemblage directory
assemblage.dir = file.path(proj.dir, "Outputs/Assemblage", gu.type, "Unit", response.pool)

# create upscale output directory
upscale.dir = file.path(proj.dir, "Outputs/Upscale", str_to_sentence(in.species), str_to_sentence(in.lifestage), "Unit", gu.type, response.pool)
if(!file.exists(upscale.dir)){dir.create(upscale.dir, recursive = TRUE)}

# delete any existing files in output directory from previous runs
unlink(file.path(upscale.dir, "*"), recursive = TRUE)


# Reads in and restructures data----------------------------------------------------

# Read in response variable by response.pool variable

# We should make more universal to upscale other responses besides pred.fish. For now, I am hardcoding this.

# read in response stats csv
response = read_csv(file.path(response.dir, "stats.csv"))

# this can be re-coded later to allow for upscaling of different ROI using alternate methods
response.area = response %>% 
  filter(variable == "area", ROI == "hydro") %>%
  select(RS, Condition, unit.type, tot) %>%
  rename(hydro.area.m2 = tot)

# filters out just data on number of fish
# this can be re-coded later to allow for upscaling of different variables
response.pred.fish = response %>%
  filter(variable == "pred.fish", ROI == "hydro")%>%
  select(RS, Condition, unit.type, tot) %>%
  rename(pred.fish = tot) # change to avg if I decided to sum up over units then average by sites in the other script

# this would give me a avg number of fish per unit type with a standard deviation.  Right now, I 
# don't have a st. deviation on number of fish

# read in estimates of assemblages

# read in assemblage area ratios
assemblage = read_csv(file.path(assemblage.dir, "assemblage.csv")) %>%
  select(-SUM)

# renormalized assemblage ratios converted to long format -- no nk code below this comment not sure if there should be something here?

# read in assemblage statistics
gu.stats = read_csv(file.path(assemblage.dir, "stats.csv"))

# total bankfull area for each unit type
# note: unit roi is only for bankfull (no hydro was calculated)
gu.bf.area = gu.stats %>%
  filter(variable == "area.sum", ROI == "bankfull") %>%
  select(RS, Condition, unit.type, tot) %>%
  rename(area.m2 = tot)

# sd bankfull area ratio for each unit type
# selects the standard deviation of assemblage ratios for each RS and condition
# note: area ratio for unit of type (i) = sum(areas for unit type (i)) / sum(areas for all units)
gu.bf.area.ratio.sd = gu.stats %>% 
  filter(variable == "area.ratio", ROI == "bankfull") %>%
  select(RS, Condition, unit.type, sd) %>%
  rename(area.ratio.sd = sd)

gu.levels = gu.stats %>% distinct(unit.type) %>% nrow()

gu.ratio.bf.area = assemblage %>%
  gather(key = "unit.type", value = "area.ratio", (length(names(assemblage)) - (gu.levels + 1)):length(names(assemblage))) %>%
  select(RS, Condition, unit.type, area.ratio) %>%
  mutate(area.ratio = as.numeric(area.ratio))

gu.ratio.bf.area$unit.type = as.factor(gu.ratio.bf.area$unit.type)


# assembling upscale data----------------------------------------------------

# Combining response and assemblage data
print("assembling upscale data")

# conditionals for dealing with different response.pools
if(response.pool == "byRSCond"){join.by = c("RS", "Condition", "unit.type")}
if(response.pool == "byRS"){join.by = c("RS", "unit.type")}
if(response.pool == "byAll"){join.by = c("unit.type")}

# computes fish density for upscale. Can be appended to later to accomodate density within hydro or wetted.
# but, I need the assemblages within the wetted extent in order to do this type of upscale.

# note - not sure why nk was creating sd.pred.fish field, setting all values to na and thent rying to use this to
#        calculate standard deviation
bf.density = gu.bf.area %>%
  #left_join(response.area, by=join.byRSCond) %>% # nk had commented out - not sure why
  left_join(gu.ratio.bf.area, by = join.by) %>%
  left_join(gu.bf.area.ratio.sd, by = join.by) %>%
  left_join(response.pred.fish, by = join.by) %>%
  #left_join(response.sd.pred.fish,by=join.byRS) Not needed unless I do my summary of response differently.
  mutate(sd.pred.fish = NA) %>%
  mutate(fish.density = pred.fish / area.m2, 
         fish.density.sd = sd.pred.fish / area.m2) %>% #could calculate also using perc habitat area, gets around the bankfull issue.
  select(RS, Condition, unit.type, area.ratio, area.ratio.sd, fish.density, fish.density.sd) %>%
  mutate(ROI = "bankfull")

# If adding more variables for upscale (ex. Model values, perc habitat, etc), could be handy to have in long (gathered) format instead.
upscale.response = bf.density

# Upscales response on the network for different scenarios ------------------------------

print("upscaling response on the network for different condition senarios")


#Estimate area based on condition and braid.index or specify user supplied areas
Estimate.Area=function(data, condcol.n, RScol.n, seg.id.col.n, length.col.n, width.col.n){
  length=data[,length.col.n]
  width=data[, width.col.n]
  C = braid.index %>% 
    select(RS, Condition, C) %>%
    right_join(data, by = c("RS", "Condition")) %>%
    select(C)
  area=length*width*as.data.frame(C)[,1]
  return(area)
}
#This is the part that does the upscaling on the network for each cond col scenario (the for loop)

#fix character warnings
for(i in 1:length(cond.cols)){ #maybe this can be changed to an lapply or something.

  cond.col = cond.cols[i]
  
  if(any(is.na(area.col), str_length(area.col) == 0)){
    upscale.network = network %>% 
      select(!!seg.id.col, RS, !!cond.col, !!length.col, !!width.col)  
    names(upscale.network) = c(seg.id.col, "RS", "Condition", "reach.length", "reach.width")
    area = Estimate.Area(data = upscale.network, condcol.n = 3, RScol.n = 2, seg.id.col.n = 1, length.col.n = 4, width.col.n = 5)
    upscale.network = upscale.network %>% 
      mutate(reach.area = area, area.method = "estimated")
  }else{
    upscale.network = network %>% 
      select(!!seg.id.col, RS, !!cond.col, !!length.col, !!width.col, !!area.col) %>%
      mutate(area.method = "given")
    names(upscale.network) = c(seg.id.col, "RS", "Condition", "reach.length", "reach.width", "reach.area", "area.method")
  }
  
  # calculate reach.braid metric 
  upscale.network = upscale.network %>% 
    mutate(reach.braid = reach.area / reach.length / reach.width)
   # head(upscale.network)

  #combine upscale network segments with response- tied to RS and condition specified on network
  upscale.network.response = upscale.network %>%
    inner_join(upscale.response %>% filter(ROI == "bankfull"), by = c("RS", "Condition")) %>%
    mutate(value = area.ratio * reach.area * fish.density) %>% #  compute estimated fish per unit type per reach
    mutate(value.sd = abs(value) * sqrt((area.ratio.sd / area.ratio)**2)) %>% #compute estimated sd of fish per unit type per reach type
    #mutate(value.sd=abs(value)*sqrt((area.ratio.sd/area.ratio)^2 + (fish.density.sd/fish.density)^2))%>% #change to this once I get the sd of fish denisty included.
    #group_by_at(seg.id.col, 'RS', 'Condition', reach.length, reach.width, reach.area, area.method, reach.braid) %>% #groups by segment id, then RS then Condition
    group_by_at(vars(seg.id.col, 'RS', 'Condition')) %>% #groups by segment id, then RS then Condition
    summarize(value = sum(value, na.rm = TRUE), value.sd = sqrt(sum(value.sd**2, na.rm = TRUE))) %>%
    ungroup() %>%
    mutate(variable = "pred.fish", Scenario = cond.col) %>% #add field that specifies which condition scenario was used.
    left_join(upscale.network %>% select(-RS, -Condition), by = seg.id.col) %>%
    select(!!seg.id.col, RS, Condition, reach.length, reach.width, reach.area, area.method, reach.braid, everything())
 
  if(i==1){
    reach.upscale = upscale.network.response
  }else{
    reach.upscale = rbind(reach.upscale, upscale.network.response)
  }
} #this is the end of the for loop.


# add additional fields
reach.upscale = reach.upscale %>%
  mutate(species = species,
         model = model,
         lifestage = lifestage,
         response.pool = response.pool,
         gu.type = gu.type)


# names(reach.upscale[1]) = seg.id.col

# group results by Scenario and RS and Condition
a = reach.upscale %>%
  group_by(Scenario, RS, Condition, area.method, model, species, variable, response.pool, gu.type)
#group results by Scenario and  RS
b = reach.upscale %>%
  group_by(Scenario, RS, area.method, model, species, variable, response.pool, gu.type)
#group results by only Scenario 
c = reach.upscale %>%
  group_by(Scenario, area.method, model, species, variable, response.pool, gu.type)  
  
#make basin summaries
reach.summary = function(grouped.data){
  grouped.data %>% summarize(value = sum(value, na.rm = TRUE), 
                          value.sd = sqrt(sum(value.sd**2, na.rm = TRUE)),
                          tot.area = sum(area, na.rm = TRUE),
                          tot.length = sum(reach.length, na.rm = TRUE),
                          mean.width = mean(reach.width, na.rm = TRUE),
                          sd.width = sd(reach.width, na.rm = TRUE),
                          mean.braid = mean(reach.braid, na.rm = TRUE),
                          sd.braid = sd(reach.braid, na.rm = TRUE))
}

basin.upscale.RSCond = reach.summary(a)
basin.upscale.RS = reach.summary(b)
basin.upscale = reach.summary(c)

#write output to file
write_csv(reach.upscale, file.path(upscale.dir, "byReach.csv"), col_names = TRUE)
write_csv(basin.upscale, file.path(upscale.dir, "byBasin.csv"), col_names = TRUE)
write_csv(basin.upscale.RS, file.path(upscale.dir, "byBasinRS.csv"), col_names = TRUE)
write_csv(basin.upscale.RSCond, file.path(upscale.dir, "byBasinRSCond.csv"), col_names = TRUE)

