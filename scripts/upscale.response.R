#Upcales reponse by unit and river style to a network

#Natalie Kramer (n.kramer.anderson@gmail.com)
#Last Updated Aug 13 2019

#Documentation available on 
#https://natalie-kramer.github.io/GeomorphicUpscale/

# To Do ------------------------------------------------------------

# !!!! Unit_Fish_Metrics_Tier*_InChannel has area.delft field (hydro model - gut unit intersection) for each unit so why aren't we using this instead of bankfull areas for each unit in upscale???
# !!!! ....so assemblage should also include proprtions for wetted
# here natalie is upscaling only by unit so what was point of generating all upscale by reach stuff?
# should have ability to upscale by reach as well?

# NK: 
#eliminate species and model from directory structure and instead include as field in output table?  Maybe append to this table
#when run for different species or just run for all species and model types on the fly-- not make a user variable...?

#get rid of condition character warnings during join in upscale part.

#upscale geomorphic variables (maybe in different script?) ex.# units to reach upscale.  Also Percent of each unit type.

#Need to think about how we are summarizing predicted fish and getting sd dev. check sd calculations for correctness.
#the right now there is none because it is the total fish / tota area of a certain unit....
#perhaps we need to be summarizing by each site and then taking the average fish per unit type across sites so that 
#the standard deviation is reflective of the variation across sites rather than across units (which I am not really using...)
#so basically I would need to sum across individual units in the response script prior to summarizing the data. Then in this script, I would just use the avg rather than the tot.

# Dependencies ------------------------------------------------------------

require(tidyverse)

source(file.path(repo.dir, "scripts/plot.colors.R"))
source(file.path(repo.dir, "scripts/functions.R"))

# user variables defined in UpscaleWrapper.R ------------------------------------------------------------

proj.dir = proj.dir  # directory path to local project
repo.dir = repo.dir   # directory path to Github repo
selections = selections # directory path to input selections file generated by RSselection.R
gu.type = gu.type      # Options: UnitForm, GU #UnitShape not available at this time since I don't have maps of these in the database
RSlevels = RSlevels # optional vector argument to set RS factor order in graphs and displays, leave as  NA if alphabetical is desired
in.species = species   # Options: steelhead, chinook
in.model = model    # Options: nrei, fuzzy
in.lifestage = lifestage  # Options: spawner, juvenile

network = network
braid.index = braid.index
response.pool = response.pool #Options: "byAll", "byRS", "byRSCond"
seg.id.col = seg.id.col
length.col = length.col
width.col = width.col
cond.cols = cond.cols
area.cols = area.cols


# set up data refs and output file structure  ------------------------------------------------------------------------
print("setting up data refs and output file structure...")

# set directories and paths ------------------------------------------------------------------------

# set response input directory
# note: str_to_sentence will convert first letter of species and lifestage to upper case
response.dir = file.path(proj.dir, "Outputs/Response", str_to_sentence(in.species), str_to_sentence(in.lifestage), "Unit", gu.type, response.pool)

# set gut assemblage directory
assemblage.dir = file.path(proj.dir, "Outputs/Assemblage", gu.type, "Unit", response.pool)

# create upscale output directory
upscale.dir = file.path(proj.dir, "Outputs/Upscale", str_to_sentence(in.species), str_to_sentence(in.lifestage), "Unit", gu.type, response.pool)
if(!file.exists(upscale.dir)){dir.create(upscale.dir, recursive = TRUE)}

# delete any existing files in output directory from previous runs
unlink(file.path(upscale.dir, "*"), recursive = TRUE)


# Reads in and restructures data----------------------------------------------------

# Read in response variable by response.pool variable

# We should make more universal to upscale other responses besides pred.fish. For now, I am hardcoding this.

# read in response stats csv
response = read_csv(file.path(response.dir, "stats.csv"))

# this can be re-coded later to allow for upscaling of different ROI using alternate methods
response.area = response %>% 
  filter(variable == "area", ROI == "hydro") %>%
  select(RS, Condition, unit.type, tot) %>%
  rename(hydro.area.m2 = tot)

# filters out just data on number of fish
# this can be re-coded later to allow for upscaling of different variables
response.pred.fish = response %>%
  filter(variable == "pred.fish", ROI == "hydro")%>%
  select(RS, Condition, unit.type, tot) %>%
  rename(pred.fish = tot) # change to avg if I decided to sum up over units then average by sites in the other script

# this would give me a avg number of fish per unit type with a standard deviation.  Right now, I 
# don't have a st. deviation on number of fish

# read in estimates of assemblages

# read in assemblage area ratios
assemblage = read_csv(file.path(assemblage.dir, "assemblage.csv"))%>%
  select(-SUM)

# renormalized assemblage ratios converted to long format -- no nk code below this comment not sure if there should be something here?

# read in assemblage statistics
gu.stats = read_csv(file.path(assemblage.dir, "stats.csv"))

# total bankfull area for each unit type
# note: unit roi is only for bankfull (no hydro was calculated)
gu.bf.area = gu.stats %>%
  filter(variable == "area.sum", ROI == "bankfull") %>%
  select(RS, Condition, unit.type, tot) %>%
  rename(area.m2 = tot)

# sd bankfull area ratio for each unit type
# selects the standard deviation of assemblage ratios for each RS and condition
# note: area ratio for unit of type (i) = sum(areas for unit type (i)) / sum(areas for all units)
gu.bf.area.ratio.sd = gu.stats %>% 
  filter(variable == "area.ratio", ROI == "bankfull") %>%
  select(RS, Condition, unit.type, sd) %>%
  rename(area.ratio.sd = sd)

gu.levels = gu.stats %>% distinct(unit.type) %>% nrow()

gu.ratio.bf.area = assemblage %>%
  gather(key = "unit.type", value = "area.ratio", (length(names(assemblage)) - (gu.levels)):length(names(assemblage))) %>%
  select(RS, Condition, unit.type, area.ratio)

gu.ratio.bf.area$unit.type = as.factor(gu.ratio.bf.area$unit.type)


# assembling upscale data----------------------------------------------------

# Combining response and assemblage data
print("assembling upscale data")

# conditionals for dealing with different response.pools
if(response.pool == "byRSCond"){join.by = c("RS", "Condition", "unit.type")}
if(response.pool == "byRS"){join.by = c("RS", "unit.type")}
if(response.pool == "byAll"){join.by = c("unit.type")}

join.byRSCond=c("RS", "Condition", "unit.type")

# computes fish density for upscale. Can be appended to later to accomodate density within hydro or wetted.
# but, I need the assemblages within the wetted extent in order to do this type of upscale.

bf.density = gu.bf.area %>%
  #left_join(response.area, by=join.byRSCond) %>% # nk had commented out - not sure why
  left_join(gu.ratio.bf.area, by = join.by) %>%
  left_join(gu.bf.area.ratio.sd, by = join.by) %>%
  left_join(response.pred.fish, by = join.by) %>%
  #left_join(response.sd.pred.fish,by=join.byRS) Not needed unless I do my summary of response differently.
  mutate(sd.pred.fish = NA) %>%
  mutate(fish.density = pred.fish / area.m2, fish.density.sd = sd.pred.fish / area.m2) %>% #could calculate also using perc habitat area, gets around the bankfull issue.
  select(RS, Condition, unit.type, area.ratio, area.ratio.sd, fish.density, fish.density.sd) %>%
  mutate(ROI="bankfull")


#If adding more variables for upscale (ex. Model values, perc habitat, etc), could be handy to have in long (gathered) format instead.
upscale.response=bf.density

# Upscales response on the network for different scenarios ------------------------------

print("upscaling response on the network for different condition senarios")

#Finds position of columns related to defined header in network file

condcols.n=match(condcols,colnames(network))
RScol.n=which(colnames(network)=="RS")
seg.id.col.n=which(colnames(network)==seg.id.col)
length.col.n=which(colnames(network)==length.col)
width.col.n=which(colnames(network)==width.col)


#This is the part that does the upscaling on the network for each cond col scenario (the for loop)

#fix character warnings
for(i in 1:length(condcols.n)){ #maybe this can be changed to an lapply or something.
  
upscale=network[,c(seg.id.col.n,RScol.n, condcols.n[i], length.col.n, width.col.n)]
names(upscale)=c(names(network)[seg.id.col.n],"RS", "Condition","reach.length", "reach.width")

#Estimate area based on condition and braid.index or specify user supplied areas
Estimate.Area=function(data, condcol.n, RScol.n, seg.id.col.n, length.col.n, width.col.n){
  length=data[,length.col.n]
  width=data[, width.col.n]
  C=braid.index%>%select(RS, Condition, C)%>%
    right_join(data, by = c("RS", "Condition"))%>%select(C)
  area=length*width*as.data.frame(C)[,1]
  return(area)
}

if(is.na(areacols)){
 area=Estimate.Area(data=upscale, condcol.n=3, RScol.n=2, seg.id.col.n=1, length.col.n=4, width.col.n=5)
 area.method="estimated"
}else{
  areacol.n=match(areacols[i],colnames(network))
  area=network[,areacol.n]
  area.method="given"
}
  
#set upscale data table for condition scenario to include area 
  upscale = upscale%>%mutate(reach.area=area, area.method=area.method)%>%mutate(reach.braid=reach.area/reach.length/reach.width)
 # head(upscale)

#combine upscale network segments with response- tied to RS and condition specified on network
upscale1=upscale%>%
    full_join(upscale.response%>%filter(ROI=="bankfull"), by=c("RS", "Condition"))%>%
    filter(!is.na(.[,1])) #removes any rows with NA for segID left over from join

#Upscale Math #if using more variables better in long format and then adjust this to be more generic, selecting by upscale variable of interest
upscale2=upscale1%>%
  mutate(value=area.ratio*reach.area*fish.density)%>% #compute estimated fish per unit type per reach
  mutate(value.sd=abs(value)*sqrt((area.ratio.sd/area.ratio)^2))%>% #compute estimated sd of fish per unit type per reach type
  #mutate(value.sd=abs(value)*sqrt((area.ratio.sd/area.ratio)^2 + (fish.density.sd/fish.density)^2))%>% #change to this once I get the sd of fish denisty included.
  group_by(.[,1], RS, Condition, reach.length, reach.width, reach.area, area.method, reach.braid)%>% #groups by segment id, then RS then Condition
  summarize(value=sum(value, na.rm=T), value.sd=sqrt(sum(value.sd^2, na.rm=T)))%>%
  mutate(variable="pred.fish")


upscale2$Scenario= names(network)[condcols.n[i]] #add field that specifies which condition scenario was used.

#math for SE rather than standard deviation
#varSE=abs(var)*sqrt(((sd/sqrt(n))/PercGU)^2+((sd.r/sqrt(n.r))/bfdensity)^2) #SE includes n
#varSD=abs(var)*sqrt((sd/PercGU)^2+(sd.bfdensity/bfdensity)^2))
 
  if(i==1){reachupscale=upscale2}else{reachupscale=rbind(reachupscale,upscale2)}
} #this is the end of the for loop.




reachupscale$species=species
reachupscale$model=model
reachupscale$lifestage=lifestage
reachupscale$response.pool=response.pool
reachupscale$gu.type=gu.type
names(reachupscale[1])=seg.id.col

#group results by Scenario and RS and Condition
a=reachupscale%>%
  group_by(Scenario, RS, Condition, area.method, model, species, variable, response.pool, gu.type )
#group results by Scenario and  RS
b=reachupscale%>%
  group_by(Scenario, RS, area.method, model, species, variable, response.pool , gu.type)
#group results by only Scenario 
c=reachupscale%>%
  group_by(Scenario, area.method, model, species,  variable, response.pool, gu.type )  
  
#make basin summaries
reachsummary=function(groupeddata){
  groupeddata%>%summarize(value=sum(value,na.rm=T), 
                          value.sd= sqrt(sum(value.sd^2, na.rm=T)),
                          tot.area=sum(area,na.rm=T),
                          tot.length=sum(reach.length, na.rm=T),
                          mean.width=mean(reach.width, na.rm=T),
                          sd.width=sd(reach.width, na.rm=T),
                          mean.braid=mean(reach.braid, na.rm=T),
                          sd.braid=sd(reach.width, na.rm=T),
  )
}

basinupscale_RSCond=reachsummary(a)
basinupscale_RS=reachsummary(b)
basinupscale=reachsummary(c)

#write output to file
write.csv(reachupscale, paste(upscale.dir, "\\" ,"byreach.csv", sep=""), row.names=F)
write.csv(basinupscale, paste(upscale.dir, "\\", "bybasin.csv", sep=""), row.names=F)
write.csv(basinupscale_RS, paste(upscale.dir, "\\", "bybasin_RS.csv", sep=""), row.names=F)
write.csv(basinupscale_RSCond, paste(upscale.dir, "\\", "bybasin_RSCond.csv", sep=""), row.names=F)


print(paste("files written to: ", upscale.dir))

# cleaning up ----------------------------------------------

# print("erasing temporary variables")
# 
# 
# keepvars=c("selections", "proj.dir","GUPdir", "plottype", "myscales" , "RSlevels", "gu.type", 
#            "species", "model", "lifestage", "network", "braid.index",
#             "response.pool", "seg.id.col", "length.col" , "width.col" , "condcols", "areacols")
# 
# rm(list=ls()[-match(x = keepvars, table = ls())])
# 
# print("done")

